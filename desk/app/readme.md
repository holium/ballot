### Installing ballot

From the dojo, run the following:

```hoon
|install our %ballot
```

Installing ballot will:

- Create a default booth based on your ship name (e.g. ~zod)
- Create a booth for all groups you own (have created)

### Running ballot

From the dojo, run the following:

```hoon
|rein %ballot [& %ballot]
```

### Usage

There are a number of ways to interact with the ballot agent:

- Directly within the dojo
- Interfacing over HTTP (REST based API)
- Signaling the agent over channels/wires

## Action / Reaction / Effects

### Action
An action is initiated by the source ship `our.bowl` (ie. a user clicks invite `~bus`, their ship (`~zod`) pokes `~bus`.

### Reaction
Reactions can be initiated by the destination ship `src.bowl` (ie. `~bus` responds to the invite action from `~zod`) or the source ship `our.bowl` (ie. `~zod` sends a reaction to `~bus`'s reaction to the original action). 

A reaction is an action that is triggered that the user doesn't initiate.

### Effects
An effect initiates a change to state based on actions and reactions. Effects are propagated in the local server only. Effects do not send pokes to other ships, they only change the state and notify the UI.

### Example
An example:
- `~zod` invites `~bus`
- `~bus` acknowledges receiving invite.

#### `~zod` flow
- **action**:   `~zod` invites '~bus`
- **effect**:  add `~bus` to local store with `status: waiting`

Now `~zod` is waiting for a reaction.

- **reaction**: `~bus` acknowledges receiving invite.
- **effect**:  `~zod` updates local store with `~bus` as `status: invited`


## Inviting a participant to a booth

```
endpoint:  /ballot/api/booths/<booth-key>
method  :  POST
payload :  see below
```

Payload definition for invite

```jsonc
{
  "action": "invite",
  "resource": "booth",
  "key": "<booth-key>", // e.g. ~zod
  "data": {
    "key": "<participant-key>" // e.g. ~bus
  }
}
```

- The booth key is extracted from the endpoint
- For now, participant-key is remote-ship name (e.g. ~bus)

### Steps

**Host ship flow:**

1. Booth host ship (e.g. ~zod) handles the POST API request
2. Booth key is extracted from endpoint
3. Participant is added to booth's participant's list w/ metadata (date created, name, generated key value (if applicable)
4. Participant's default status is set to 'pending'
5. Remote ship (participant key as ship) is poked w/ invite action and booth information obtained from host ship booth store.
6. If remote ship is offline, poke is queued for later delivery. In this case, participant remains in pending state until remote ship starts or awakens.
7. On success, host ship API request responds w/ 200 and the following data:

```jsonc
{
  "action": "invite",
  "resource": "booth",
  "reaction": "pending",
  "key": "<booth-key>",
  "data": {
    "key": "<participant-key>",
    "name": "<participant-name>", // i.e. key
    "status": "pending",
    "created": <timestamp> // epoch time in seconds
    // ...   whatever else we think we need
  }
}
```

**Remote ship flow:**

1. Remote ship (e.g. ~bus) receives "invite" action via poke
2. Creates booth entry with booth information sent by host ship
3. Updates the status of the booth on the remote-ship (~bus) to `invited`.
4. Sends the following effects:

```
 1. sends update to UI over channel with action|reaction|effect payload

 2. nods to booth host ship (via poke). Note that a nod reaction is generated by the host-ship when the default Gall poke response is received w/ an ack (null or ~ unit). The host ship will then generate an `invite` payload w/ a 'nod' reaction. The action payload will mimic the original request payload.

 3. acks to booth host ship (via poke)
```

**Reaction/Effect contracts sent by remote ship:**

Update effect to UI (1)

UI (~bus) receives over channel:

```jsonc
{
  "action": "invite-effect",
  "resource": "booth",
  "reaction": "ack",
  "key": "<booth-key>",
  "data": {
    // booth information here (based on booth data provided by original "invite" action from host ship)
    "key": "<booth-key>",
    "name": ...
    "status": "invited",
    ...
  }
}
```

`nod` reaction to original poke (2)

> Note from the description above, that a 'nod' reaction is simply ack'ing the original poke (Step #5 from host ship flow). In this case, the participant record on the host ship (~zod) is updated with a status of `awake`.

`ack` reaction to `invite` action (3)

**Host ship (~zod) receives:**

```jsonc
{
  "action": "invite-response",
  "resource": "booth",
  "reaction": "ack",
  "key": "<booth-key>",
  "data": {
    "key": "<participant-key>"
  }
}
```

**Host (~zod) response processing flow of `nod` reaction:**

1. Host/origin (~zod) receives `ack` to original poke
2. Participant record on host ship is updated to `awake`
3. Message is sent to UI on host ship (~zod)

`nod` reaction (i.e. gall agent ack) to host's poke action (3)

UI (~zod) receives (3):

```jsonc
{
  "action": "invite",
  "resource": "booth",
  "reaction": "node",
  "key": "<booth-key>",
  "data": {
    "key": "<participant-key>",
    "status": "awake"
  }
}
```

**Host (~zod) response processing flow of `ack` reaction:**

1. Host/origin agent (~zod) intercepts the `invite-response` poke from the remote ship (~bus)
2. Participant record on host ship is updated to `invited`
3. Message is sent to UI on host ship (~zod)

`ack` reaction to `invite` action (3)

UI (~zod) receives (3):

```jsonc
{
  "action": "invite",
  "resource": "booth",
  "reaction": "ack",
  "key": "<booth-key>",
  "data": {
    "key": "<participant-key>",
    "status": "invited"
  }
}
```

**Error Handling Actions**

1. During an initial action POST, if an error occurs, an HTTP error-code 500 will be sent w/ the original action payload and an additional `error` element in the `data` element. Note that this error message is not guaranteed to exist, but if it's there can provide additional insight into the error for display purposes.

```jsonc
{
  "action": "invite",
  ...
  "data": {
    ...
    [optional] "error": string,
  }
```

2. If an error occurs during the initial/original invite action poke processing (on the remote ship), the original action payload, a reaction of `nack`, and an optional `error` element will be provided in the `data` element:

```jsonc
{
  "action": "invite",
  "reaction": "nack",
  ...
  "data": {
    ...
    [optional] "error": string,
  }
```

3. If an error occurs during on the remote ship during any other part of action processing, the original action payload, a reaction of `err`, and an optional `error` element will be provided in the `data` element:

```jsonc
{
  "action": "invite",
  "reaction": "err",
  ...
  "data": {
    ...
    [optional] "error": string,
  }
```

Note: You should only ever get at most one `nack` per action. It is possible however to receive one or more `err` reactions depending on the nature of the action being requested.
